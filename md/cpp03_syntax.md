# 非モダンC++
このドキュメントでの非モダンC++とはC++03までのC++を指す。
従って、C++から導入された以下のシンタックスは本章の対象外となる。

- スマートポインタ(ダイナミックメモリアロケーションで生成されたオブジェクトの自動開放)
- 右辺値参照 / ムーブセマンティクス
- 範囲forループ
- ラムダ式
- auto/decltypeによる型推論
- テンプレートの強化(パラメータパック、SFINAE強化等)

非モダンC++はC09のシンタックスと以下のようなシンタックスやライブラリから形作られる。
なお、C09のシンタックスについての知識が不十分な場合、
本ドキュメントを読み進める前に、
[プログラミング言語Ci](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9EC-%E7%AC%AC2%E7%89%88-ANSI%E8%A6%8F%E6%A0%BC%E6%BA%96%E6%8B%A0-B-W-%E3%82%AB%E3%83%BC%E3%83%8B%E3%83%8F%E3%83%B3/dp/4320026926/ref=sr_1_3?dib=eyJ2IjoiMSJ9.9Y_CW98q5Eu6U4fMPe6uvEk0WTyCyc9HJeKOSU9VvnvGjHj071QN20LucGBJIEps.W4xuvhyS-yLi38GF8W6XUxu0IowUfHtbcHdfKVWPa8s&dib_tag=se&qid=1756356689&refinements=p_27%3AB.W.+%E3%82%AB%E3%83%BC%E3%83%8B%E3%83%8F%E3%83%B3&s=books&sr=1-3&text=B.W.+%E3%82%AB%E3%83%BC%E3%83%8B%E3%83%8F%E3%83%B3)
の熟読を薦める。

- [クラス](---)関連
- [リファレンス](--)(参照)
- テンプレート
- 名前空間
- 例外処理
- RTTI
- 使いされた型(bool, wchar_t)
- キャスト
- 演算子
    - ::, `.*`, `->*`
    - new, delete
    - 演算子オーバーロード(operator 構文)


## クラス
この節ではクラスの概念とシンタックスを解説する。
C++におけるクラスは、C90でも規定されている`struct`と、
C++で規定されている`class`によってユーザが定義する型である。
C++での`struct`と`class`は以下の点について異なるが、概念としては同一であると考えられる。

* [アクセス指定子](---)無しでのメンバへのアクセス
    - structではデフォルトが`public`
    - classではデフォルトが`private`

* [アクセス指定子](---)無しでの継承
   - `struct`からの継承はデフォルトで`public`
   - `class`からの継承はデフォルトで`private`

すなわち、両者の違いはデフォルトのアクセス指定にとどまり、機能的な差は存在しない。
したがって、利用者は設計意図に応じてstructまたはclassを選択すればよい。
一般的には、データ構造的な性格が強い単純な型にはstructを、
カプセル化を意識した抽象化された型にはclassを用いる慣習がある。

cでの`struct`は以下の点において、c++での`struct`と異なる。

* [非モダンC++|クラス|メンバ関数](---)の定義
* デフォルトの[メンバ変数の初期化](---)
* [アクセス指定子](---)
* [継承](---)

### メンバ関数
メンバ関数とは、クラスに属し、そのインスタンスを通じて呼び出される関数である。
インスタンスの状態を操作したり、外部からの要求に応じて振る舞いを定義するために使用される。

メンバ関数には、用途が限定された特殊な関数がある。

* コンストラクタ
  インスタンス生成時に呼ばれる特別な関数。
  メンバ変数の初期化やリソース確保を行う。

* デストラクタ
  インスタンス破棄時に呼ばれる特別な関数。
  リソース解放などの後処理を行う。

* コピーコンストラクタ / コピー代入演算子
  オブジェクトのコピー動作を制御する。

* ムーブコンストラクタ / ムーブ代入演算子
  一時オブジェクトやリソースの所有権を効率的に移動させるため、
  導入された[C++11の主な新規機能](---)である。説明は後述する。

#### コンストラクタ

#### デストラクタ


### メンバ変数の初期化

### 継承

### アクセス指定子

アクセス指定子とは、クラスや構造体のメンバ(データメンバやメンバ関数)に対して、
外部からのアクセスをどの範囲まで許すかを指定する仕組みである。
C++では以下の3種類のアクセス指定子が存在する。

* public
  - どこからでもアクセス可能。
  - クラスの利用者が使用するインターフェース（関数や定数など）を公開する場合に用いる。

* protected
  - クラス自身とその派生クラスからのみアクセス可能。
  - 外部からは直接アクセスできない。
  - 継承関係における拡張を意図した場合に利用される。

* private
  - クラス自身からのみアクセス可能。
  - 派生クラスや外部からは直接アクセスできない。
  - データの隠蔽(カプセル化)を実現するための基本的な指定子。

なお、デフォルトのアクセス指定は次の通りである。

* class：デフォルトはprivate
* struct：デフォルトはpublic

### クラスの使用例
まずは、C言語で文字列を接続する下記の関数をより使いやすく修正してくことで、クラスを説明する。

```cpp
    // @@@ example/cpp03_syntax/c_syle_ut.cpp #0:0 begin
```

上記c_str_addのテストは以下のように行うことができる。


```cpp

    // @@@ example/cpp03_syntax/c_syle_ut.cpp #0:1 begin -1
```

一般に単体テストを実施することの意義は、以下の2つである。

1. 対象の関数の動作確認を局所的に行うことができる。
2. 対象の関数の使用方法の不備を発見することができる。


単体テストの意義2によりc_str_addの問題点は以下のようにまとめることができる。

* メモリリークの危険性: 呼び出し側がfreeし忘れるとリークする。
* ヌルポインタ操作の脆弱性: NULLチェック漏れ・NULLへのfreeで未定義動作。
* 二重解放・ダングリングポインタ: 同じポインタを2回free、またはfree後にアクセスの可能性。
* 関数の戻り値を解放責務の所在がはっきりしないため、発見、修正困難なバグにつながりやすい。

そもそも、これらの問題はc_str_addの問題というよりも、
Cのプログラミングパラダイムのの限界であると考えられる。
C++ではこのような問題をクラスとその[デストラクタ](---)を用いて下記のように解決する。

```cpp
    // @@@ example/cpp03_syntax/c_syle_ut.cpp #1:0 begin
```

```cpp
    // @@@ example/cpp03_syntax/c_syle_ut.cpp #1:1 begin
```

## リファレンス




