# 非モダンC++
このドキュメントでの非モダンC++とはC++03までのC++を指す。
従って、C++から導入された以下のシンタックスは本章の対象外となる。

- スマートポインタ(ダイナミックメモリアロケーションで生成されたオブジェクトの自動開放)
- 右辺値参照 / ムーブセマンティクス
- 範囲forループ
- ラムダ式
- auto/decltypeによる型推論
- テンプレートの強化(パラメータパック、SFINAE強化等)

非モダンC++はC98のシンタックスと以下のようなシンタックスやライブラリから形作られる。
なお、C98のシンタックスについての知識が不十分な場合、
本ドキュメントを読み進める前に、
[プログラミング言語Ci](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9EC-%E7%AC%AC2%E7%89%88-ANSI%E8%A6%8F%E6%A0%BC%E6%BA%96%E6%8B%A0-B-W-%E3%82%AB%E3%83%BC%E3%83%8B%E3%83%8F%E3%83%B3/dp/4320026926/ref=sr_1_3?dib=eyJ2IjoiMSJ9.9Y_CW98q5Eu6U4fMPe6uvEk0WTyCyc9HJeKOSU9VvnvGjHj071QN20LucGBJIEps.W4xuvhyS-yLi38GF8W6XUxu0IowUfHtbcHdfKVWPa8s&dib_tag=se&qid=1756356689&refinements=p_27%3AB.W.+%E3%82%AB%E3%83%BC%E3%83%8B%E3%83%8F%E3%83%B3&s=books&sr=1-3&text=B.W.+%E3%82%AB%E3%83%BC%E3%83%8B%E3%83%8F%E3%83%B3)
の熟読を薦める。

- [クラス](---)関連
- [リファレンス](--)(参照)
- テンプレート
- 名前空間
- 例外処理
- RTTI
- 使いされた型(bool, wchar_t)
- キャスト
- 演算子
    - ::, `.*`, `->*`
    - new, delete
    - 演算子オーバーロード(operator 構文)

___

__この章の構成__

<!-- index 1-4 -->

[このドキュメントの構成](---)に戻る。  

___


## クラス
この節ではクラスの概念とシンタックスを解説する。
C++におけるクラスは、C90でも規定されている`struct`と、
C++で規定されている`class`によってユーザが定義する型である。
C++での`struct`と`class`は以下の点について異なるが、概念としては同一であると考えられる。

* [アクセス指定子](---)無しでのメンバへのアクセス
    - structではデフォルトが`public`
    - classではデフォルトが`private`

* [アクセス指定子](---)無しでの継承
   - `struct`からの継承はデフォルトで`public`
   - `class`からの継承はデフォルトで`private`

すなわち、両者の違いはデフォルトのアクセス指定にとどまり、機能的な差は存在しない。
したがって、利用者は設計意図に応じてstructまたはclassを選択すればよい。
一般的には、データ構造的な性格が強い単純な型にはstructを、
カプセル化を意識した抽象化された型にはclassを用いる慣習がある。

cでの`struct`は以下の点において、c++での`struct`と異なる。

* [非モダンC++|クラス|メンバ関数](---)の定義
* デフォルトの[メンバ変数の初期化](---)
* [アクセス指定子](---)
* [継承](---)

### メンバ関数
メンバ関数とは、クラスに属し、そのインスタンスを通じて呼び出される関数である。
インスタンスの状態を操作したり、外部からの要求に応じて振る舞いを定義するために使用される。

Cとの比較の例を用いて、メンバ関数を導入する。
まずは、以下の構造体と関数の組み合わせのコード例について見ていこう。

```cpp
    // @@@ example/cpp03_syntax/class_ut_0.cpp #0:0 begin
```

上記のcalc_bmiはPersonインスタンスからBMIを導き出す関数である。
以下にPersonとcalc_bmiの使用例を示す。

```cpp
    // @@@ example/cpp03_syntax/class_ut_0.cpp #0:1 begin -1
```

C++では、上記のような場合、メンバ関数を使用して、下記のように記述する。

```cpp
    // @@@ example/cpp03_syntax/class_ut_1.cpp #0:0 begin
```

なお、Person::calc_bmiは、 calc_bmiがPersonのメンバであることを表す。
Person::calc_bmi()の使用方法は、以下のとおりである。

```cpp
    // @@@ example/cpp03_syntax/class_ut_1.cpp #0:1 begin -1
```

上記例でのPersonのインスタンスpersonは適切に初期化されているが、
Person::height_cmを0で初期されたpersonはcalc_bmiに0除算を発生させてしまう。
クラスの制限に適合するインスタンスを生成できるようにするためのシンタックスが、
特殊なメンバ関数である[コンストラクタ](---)である。


Person::calc_bmi()のような一般のメンバ関数以外に用途が限定された以下のような特殊な関数がある。

* [コンストラクタ](---)
* [デストラクタ](---)
* [コピーコンストラクタ/コピー代入演算子](---)
* [ムーブコンストラクタ/ムーブ代入演算子](---)


### コンストラクタ
インスタンス生成時に呼ばれる特別なメンバ関数であり、メンバ変数の初期化やリソース確保を行う。


以下のコードでは、前例のPersonにコンストラクタを定義する。

```cpp
    // @@@ example/cpp03_syntax/class_ut_2.cpp #0:0 begin
```

コンストラクタが定義されたクラスのインスタンス化は以下のように行う。

```cpp
    // @@@ example/cpp03_syntax/class_ut_2.cpp #0:1 begin -1
```

コンストラクタは戻り値を持つことはできないため、引数がクラスの制限に収まらない場合、
エラーを返すことができない。
そのような場合、
[エクセプション](---)を送出させることにより、呼び出し元にエラーを通知させることができるが、
エクセプション送出については後述する
(この例では、コンストラクタの不正な引数のチェックに`assert()`を用いている)。

次の例では前出のPersonに以下の仕様を満たすget_full_name()を追加する。

* ヒープから適切なサイズのメモリを取得して、そのポインタをfull_nameに保存する
* 取得したメモリに、family_nameとfirst_nameを適切にコピーしてフルネームを生成する
* full_nameに保存したポインタを返す

```cpp
    // @@@ example/cpp03_syntax/class_ut_3.cpp #0:0 begin
```

クラスを修正した場合、当然それに合わせて単体テストコードも修正が必要である。

```cpp
    // @@@ example/cpp03_syntax/class_ut_3.cpp #0:1 begin -1
```

単体テストで示したようにこの関数は想定通り動作するが、メモリーリークを引き起こす。
これに対処するためのメンバ関数が[デストラクタ](---)である。

### デストラクタ
インスタンス破棄時に呼ばれる特別なメンバ関数であり、リソース解放などの後処理を行う。

以下の例では前節で指摘したメモリーリークのバグをデストラクタを用いて対処する。


```cpp
    // @@@ example/cpp03_syntax/class_ut_4.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/class_ut_4.cpp #0:1 begin -1
```

### アクセス指定子

アクセス指定子とは、クラスや構造体のメンバ(データメンバやメンバ関数)に対して、
外部からのアクセスをどの範囲まで許すかを指定する仕組みである。
C++では以下の3種類のアクセス指定子が存在する。

* public
  - どこからでもアクセス可能。
  - クラスの利用者が使用するインターフェース（関数や定数など）を公開する場合に用いる。

* protected
  - クラス自身とその派生クラスからのみアクセス可能。
  - 外部からは直接アクセスできない。
  - 継承関係における拡張を意図した場合に利用される。

* private
  - クラス自身からのみアクセス可能。
  - 派生クラスや外部からは直接アクセスできない。
  - データの隠蔽(カプセル化)を実現するための基本的な指定子。

なお、デフォルトのアクセス指定は次の通りである。

* class：デフォルトはprivate
* struct：デフォルトはpublic

### アクセス指定子の使用例
これまで例として使ってきたPersonのメンバ変数は以下のような制約を持つ。

* family_nameとfirst_nameはNULLでなく、文字列リテラル
* full_nameはNULLであるか、family_nameとfirst_nameから生成されるヒープ上の文字列
* height_cmとweight_kgは0でない

これらの制約が外部から変更された場合、Personが正常にできないことがある。
このような問題を避けるために、クラスは[アクセス指定子](---)を使用し、
メンバへのアクセスを制御することが一般的である。

これまでクラスは`struct`を使用してきたが、ここで、
[アクセス指定子](---)と`class`を使用し、以下のようにPersonのリファクタリングを行う。

```cpp
    // @@@ example/cpp03_syntax/class_ut_5.cpp #0:0 begin
```

### staticメンバ
`static`メンバは、クラスの各インスタンスに属するのではなく、
クラス全体で共有されるメンバを定義するために使用される。

* staticメンバ変数
    - すべてのインスタンスで共通のデータを保持する。
    - 通常のメンバ変数と異なり、オブジェクト生成に依存せず存在する。
    - Cの静的変数と同様に初期化される。

* 静的メンバ関数
    - インスタンスに依存せずに呼び出せる関数。
    - [this](---)ポインタを持たないため、非静的メンバ変数や非静的メンバ関数に直接アクセスできない。
    - クラスのユーティリティ的な操作や、静的メンバ変数の操作に利用される。


前出のPerson::get_full_name()の実装に使用したmake_full_nameは、
以下の例のようにstaticな関数にすることができる。
上記したようにPerson::get_full_name()はメンバ変数に直接アクセスできないため、
通用のメンバ関数に比べて制限が多い分、可読性が向上する。

```cpp
    // @@@ example/cpp03_syntax/class_ut_6.cpp #0:0 begin
```

publicなstaitcメンバへのクラス外でのアクセスには、
下記コードの例のようにクラス名修飾(任意のクラス名Tに対してT::member)がに必要になる。

```cpp
    // @@@ example/cpp03_syntax/class_ut_6.cpp #0:1 begin -1
```


staticメンバ変数を使用し、さらにPersonに以下のような変更を加える。

* Personのインスタンスの数を数えるstaticなpublicメンバ変数の追加
* Personのコンストラクタ呼び出し時にPerson::full_nameの初期化
* Person::make_full_nameをクラス内部での使用専用にするためにprivate化

```cpp
    // @@@ example/cpp03_syntax/class_ut_6.cpp #1:0 begin
```

コードの修正した場合、それに合わせて単体テストも修正する必要がある。

```cpp
    // @@@ example/cpp03_syntax/class_ut_6.cpp #1:1 begin -1
```

### コピーコンストラクタ/コピー代入演算子

コピーコンストラクタとは、

* 型Tに対して、`T(T const&)`のようなシグネチャのコンストラクタの一種である。
* オブジェクトのコピー初期化を制御するためのメンバ関数である。
* コピーコンストラクタをユーザが定義しない場合、自動的に暗黙定義される。

コピー代入演算子とは、

* 型Tに対して、`operator =(T const&)`のようなシグネチャの[特殊メンバ関数](---)である。
* Tオブジェクトに別のTオブジェクトを代入するための[特殊メンバ関数](---)である。
* コピー代入演算子をユーザが定義しない場合、自動的に暗黙定義される。


```cpp
    // @@@ example/cpp03_syntax/c_syle_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/c_syle_ut.cpp #0:1 begin -1
```

上記のコードは「Cの構造体インスタンスの`=`による代入は、
メンバの逐次コピーによって全体の代入や初期化が行われる」ことを示している。

C++では、この挙動がそのまま「暗黙定義されたコピーコンストラクタ／コピー代入演算子」
として取り込まれている。


すなわち、Cの構造体のコピーと同様に、C++のクラスでもユーザが特別に定義しなければ、
すべてのメンバが逐次コピーされる。

ただし、この方法ではポインタ型のメンバも単純にアドレスがコピーされるため、
リソースの二重解放や参照の共有によるバグの原因となる可能性がある。

以下は二重解放バグの典型的なコード例である([staticメンバ](---)の例からメンバ変数を除いている)。

```cpp
    // @@@ example/cpp03_syntax/class_ut_7.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/class_ut_7.cpp #0:1 begin -1
```


そのため、C++では動的メモリや外部リソースを扱うクラスでは、
コピーコンストラクタやコピー代入演算子を明示的に定義し、
必要に応じて[ディープコピー](---)を実装することが重要である。




### ムーブコンストラクタ/ムーブ代入演算子
一時オブジェクトやリソースの所有権を効率的に移動させるため、
導入された[C++11の主な新規機能](---)である。

### メンバ変数の初期化

### this

### 継承

--- 

## エクセプション

## リファレンス




