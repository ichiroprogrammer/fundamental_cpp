# 非モダンC++
このドキュメントでの非モダンC++とはC++03までのC++を指す。
従って、C++から導入された以下のシンタックスや標準ライブラリは本章の対象外となる。

- [スマートポインタ](---)(ダイナミックメモリアロケーションで生成されたオブジェクトの自動開放)
- [rvalueリファレンス](---)(右辺値参照)/ [moveセマンティクス](---)
- 範囲forループ
- ラムダ式
- auto/decltypeによる型推論
- テンプレートの強化(パラメータパック、SFINAE強化等)

非モダンC++はC90のシンタックスと以下のようなシンタックスやライブラリから形作られる。
なお、C90のシンタックスについての知識が不十分な場合、
本ドキュメントを読み進める前に、
[プログラミング言語C](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9EC-%E7%AC%AC2%E7%89%88-ANSI%E8%A6%8F%E6%A0%BC%E6%BA%96%E6%8B%A0-B-W-%E3%82%AB%E3%83%BC%E3%83%8B%E3%83%8F%E3%83%B3/dp/4320026926/ref=sr_1_3?dib=eyJ2IjoiMSJ9.9Y_CW98q5Eu6U4fMPe6uvEk0WTyCyc9HJeKOSU9VvnvGjHj071QN20LucGBJIEps.W4xuvhyS-yLi38GF8W6XUxu0IowUfHtbcHdfKVWPa8s&dib_tag=se&qid=1756356689&refinements=p_27%3AB.W.+%E3%82%AB%E3%83%BC%E3%83%8B%E3%83%8F%E3%83%B3&s=books&sr=1-3&text=B.W.+%E3%82%AB%E3%83%BC%E3%83%8B%E3%83%8F%E3%83%B3)
の熟読を薦める。

- [クラス](---)関連
- [リファレンス](--)(参照)
- テンプレート
- 名前空間
- 例外処理
- RTTI
- 追加された型(bool, wchar_t)
- キャスト
- 演算子
    - ::, `.*`, `->*`
    - new, delete
    - 演算子オーバーロード(operator 構文)

___

__インデックス__

<!-- index 1-4 -->

[インデックス](---)に戻る。  

___


## クラス
この節ではクラスの概念とシンタックスを解説する。
C++におけるクラスは、C90でも規定されている`struct`と、
C++で規定されている`class`によってユーザが定義する型である。
C++での`struct`と`class`は以下の点について異なるが、概念としては同一であると考えられる。

* [アクセス指定子](---)無しでのメンバへのアクセス
    - structではデフォルトが`public`
    - classではデフォルトが`private`

* [アクセス指定子](---)無しでの継承
   - `struct`からの継承はデフォルトで`public`
   - `class`からの継承はデフォルトで`private`

すなわち、両者の違いはデフォルトのアクセス指定にとどまり、機能的な差は存在しない。
したがって、利用者は設計意図に応じてstructまたはclassを選択すればよい。
一般的には、データ構造的な性格が強い単純な型にはstructを、
カプセル化を意識した抽象化された型にはclassを用いる慣習がある。

Cでの`struct`は以下の点において、C++での`struct`と異なる。

* [非モダンC++|クラス|メンバ関数](---)の定義
* デフォルトのメンバ変数の初期化(そのメンバ変数がデフォルトコンストラクタを持っている場合)
* [アクセス指定子](---)
* [継承](---)

### メンバ関数
メンバ関数とは、クラスに属し、そのインスタンスを通じて呼び出される関数である。
インスタンスの状態を操作したり、外部からの要求に応じて振る舞いを定義するために使用される。

Cとの比較の例を用いて、メンバ関数を導入する。
まずは、以下の構造体と関数の組み合わせのコード例について見ていこう。

```cpp
    // @@@ example/cpp03_syntax/class_00_ut.cpp #0:0 begin
```

上記のcalc_bmiはPersonインスタンスからBMIを導き出す関数である。
以下にPersonとcalc_bmiの使用例を示す。

```cpp
    // @@@ example/cpp03_syntax/class_00_ut.cpp #0:1 begin -1
```

C++では、上記のような場合、メンバ関数を使用して、下記のように記述する。

```cpp
    // @@@ example/cpp03_syntax/class_01_ut.cpp #0:0 begin
```

なお、Person::calc_bmiは、 calc_bmiがPersonのメンバであることを表す。
Person::calc_bmi()の使用方法は、以下のとおりである。

```cpp
    // @@@ example/cpp03_syntax/class_01_ut.cpp #0:1 begin -1
```

上記例でのPersonのインスタンスpersonは適切に初期化されているが、
Person::height_cmを0で初期されたpersonはcalc_bmiに0除算を発生させてしまう。
クラスの制限に適合するインスタンスを生成できるようにするためのシンタックスが、
特殊なメンバ関数である[コンストラクタ](---)である。


Person::calc_bmi()のような一般のメンバ関数以外に用途が限定された以下のような特殊な関数がある。

* [コンストラクタ](---)
* [デストラクタ](---)
* [コピーコンストラクタ/コピー代入演算子](---)


### コンストラクタ
インスタンス生成時に呼ばれる特別なメンバ関数であり、メンバ変数の初期化やリソース確保を行う。

以下のコードでは、前例のPersonにコンストラクタを定義する。

```cpp
    // @@@ example/cpp03_syntax/class_02_ut.cpp #0:0 begin
```

コンストラクタが定義されたクラスのインスタンス化は以下のように行う。

```cpp
    // @@@ example/cpp03_syntax/class_02_ut.cpp #0:1 begin -1
```

### メンバ変数の初期化リスト
[コンストラクタ](---)のコード例で示したメンバ変数の初期化は、慣習的には初期化と呼ばれるが、
正確にはメンバ変数への値の代入である。
前記したコード例では、メンバ変数の初期化リストを以下のように使用するべきである
([constメンバ変数](---)の初期化を行うためには、初期化リストが必須)。

なお、メンバ変数の初期化順序は、メンバ変数の初期化リストの順とは関係なく、
変数の宣言の順に従うため注意が必要である。
従って、メンバ変数の宣言の順で、初期化リストを並べるのがセオリーとなっている。

```cpp
    // @@@ example/cpp03_syntax/class_02_ut.cpp #1:0 begin
```

```cpp
    // @@@ example/cpp03_syntax/class_02_ut.cpp #1:1 begin -1
```

コンストラクタは戻り値を持つことはできないため、引数がクラスの制限に収まらない場合、
エラーを返すことができない。そのような場合、
すでに示したコード例のように、[エクセプションのthrow](---)によって呼び出し元にエラーを通知することができる。

### デストラクタ

次の例では前出のPersonに以下の仕様を満たすget_full_name()を追加する。

* ヒープから適切なサイズのメモリを取得して、そのポインタをfull_nameに保存する
* 取得したメモリに、family_nameとfirst_nameを適切にコピーしてフルネームを生成する
* full_nameに保存したポインタを返す

```cpp
    // @@@ example/cpp03_syntax/class_03_ut.cpp #0:0 begin
```

クラスを修正した場合、当然それに合わせて単体テストコードも修正が必要である。

```cpp
    // @@@ example/cpp03_syntax/class_03_ut.cpp #0:1 begin -1
```

単体テストで示したようにこの関数は想定通り動作するが、メモリーリークを引き起こす。
これに対処するためのメンバ関数が[デストラクタ](---)である。

インスタンス破棄時に呼ばれる特別なメンバ関数であり、リソース解放などの後処理を行う。

以下の例では前節で指摘したメモリーリークのバグをデストラクタを用いて対処する。


```cpp
    // @@@ example/cpp03_syntax/class_04_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/class_04_ut.cpp #0:1 begin -1
```

### アクセス指定子

アクセス指定子とは、クラスや構造体のメンバ(データメンバやメンバ関数)に対して、
外部からのアクセスをどの範囲まで許すかを指定する仕組みである。
C++では以下の3種類のアクセス指定子が存在する。

* public
  - どこからでもアクセス可能。
  - クラスの利用者が使用するインターフェース(関数や定数など)を公開する場合に用いる。

* protected
  - クラス自身とその派生クラスからのみアクセス可能。
  - 外部からは直接アクセスできない。
  - 継承関係における拡張を意図した場合に利用される。

* private
  - クラス自身からのみアクセス可能。
  - 派生クラスや外部からは直接アクセスできない。
  - データの隠蔽(カプセル化)を実現するための基本的な指定子。

なお、デフォルトのアクセス指定は次の通りである。

* class：デフォルトはprivate
* struct：デフォルトはpublic

### アクセス指定子の使用例
これまで例として使ってきたPersonのメンバ変数は以下のような制約を持つ。

* family_nameとfirst_nameはNULLでなく、文字列リテラル
* full_nameはNULLであるか、family_nameとfirst_nameから生成されるヒープ上の文字列
* height_cmとweight_kgは0でない

これらの制約が外部から変更された場合、Personが正常に動作しないことがある。
このような問題を避けるために、クラスは[アクセス指定子](---)を使用し、
メンバへのアクセスを制御することが一般的である。

これまでクラスは`struct`を使用してきたが、ここで、
[アクセス指定子](---)と`class`を使用し、以下のようにPersonのリファクタリングを行う。

```cpp
    // @@@ example/cpp03_syntax/class_05_ut.cpp #0:0 begin
```

### staticメンバ
`static`メンバは、クラスの各インスタンスに属するのではなく、
クラス全体で共有されるメンバを定義するために使用される。

* staticメンバ変数
    - すべてのインスタンスで共通のデータを保持する。
    - 通常のメンバ変数と異なり、オブジェクト生成に依存せず存在する。
    - Cの静的変数と同様に初期化される。

* 静的メンバ関数
    - インスタンスに依存せずに呼び出せる関数。
    - [this](---)ポインタを持たないため、非静的メンバ変数や非静的メンバ関数に直接アクセスできない。
    - クラスのユーティリティ的な操作や、静的メンバ変数の操作に利用される。


前出のPerson::get_full_name()の実装に使用したmake_full_nameは、
以下の例のようにstaticな関数にすることができる。
上記したようにPerson::make_full_name()はメンバ変数に直接アクセスできないため、
通常のメンバ関数に比べて制限が多い分、可読性が向上する。

```cpp
    // @@@ example/cpp03_syntax/class_06_ut.cpp #0:0 begin
```

publicなstaitcメンバへのクラス外でのアクセスには、
下記コードの例のようにクラス名修飾(任意のクラス名Tに対してT::member)がに必要になる。

```cpp
    // @@@ example/cpp03_syntax/class_06_ut.cpp #0:1 begin -1
```


staticメンバ変数を使用し、さらにPersonに以下のような変更を加える。

* Personのインスタンスの数を数えるstaticなpublicメンバ変数の追加
* Personのコンストラクタ呼び出し時にPerson::full_nameの初期化
* Person::make_full_nameをクラス内部での使用専用にするためにprivate化

```cpp
    // @@@ example/cpp03_syntax/class_06_ut.cpp #1:0 begin
```

コードを修正した場合、それに合わせて単体テストも修正する必要がある。

```cpp
    // @@@ example/cpp03_syntax/class_06_ut.cpp #1:1 begin -1
```

### コピーコンストラクタ/コピー代入演算子
コピーコンストラクタとは、

* 型Tに対して、`T(T const&)`のようなシグネチャのコンストラクタの一種である。
* オブジェクトのコピー初期化を制御するためのメンバ関数である。
* コピーコンストラクタをユーザが定義しない場合、自動的に暗黙定義される。

コピー代入演算子とは、

* 型Tに対して、`operator =(T const&)`のようなシグネチャの[特殊メンバ関数](---)である。
* Tオブジェクトに別のTオブジェクトを代入するための[特殊メンバ関数](---)である。
* コピー代入演算子をユーザが定義しない場合、自動的に暗黙定義される。

```cpp
    // @@@ example/cpp03_syntax/c_syle_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/c_syle_ut.cpp #0:1 begin -1
```

上記のコードは「Cの構造体インスタンスの`=`による代入は、
メンバの逐次コピーによって全体の代入や初期化が行われる」ことを示している。

C++では、この挙動がそのまま「暗黙定義されたコピーコンストラクタ/コピー代入演算子」
として取り込まれている。

すなわち、Cの構造体のコピーと同様に、C++のクラスでもユーザが特別に定義しなければ、
すべてのメンバが逐次コピーされる。

ただし、この方法ではポインタ型のメンバも単純にアドレスがコピーされるため、
リソースの二重解放や参照の共有によるバグの原因となる可能性がある。

以下は二重解放バグの典型的なコード例である([staticメンバ](---)の例からメンバ変数を除いている)。

```cpp
    // @@@ example/cpp03_syntax/class_07_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/class_07_ut.cpp #0:1 begin -1
```

三の原則(Rule of Three)に従うことで上記の問題を避けることができる
(C++11ではこの原則は[五の原則(Rule of Five)](---)に拡張された)。

* オブジェクト生成時にリソースを確保するようなクラスは、ユーザが定義したデストラクタを持つ必要がある。
* ユーザが定義したデストラクタを持つクラスはコピーコンストラクタを持つ必要がある。
* ユーザが定義したコピーコンストラクタを持つクラスはコピー代入演算子を持つ必要がある。

以下にこの原則に従ったPersonを示す。

```cpp
    // @@@ example/cpp03_syntax/class_08_ut.cpp #0:0 begin
```

以下にコピーコンストラクタの実装を示す。

```cpp
    // @@@ example/cpp03_syntax/class_08_ut.cpp #0:1 begin
```

以下にコピー代入演算子の実装を示す。

```cpp
    // @@@ example/cpp03_syntax/class_08_ut.cpp #0:2 begin
```

以下にコピーコンストラクタ/コピー代入演算子のテストを示す。

```cpp
    // @@@ example/cpp03_syntax/class_08_ut.cpp #1:0 begin -1
```

一般に、T型のコピー代入演算子の戻り値型を`T&`にすることで以下のようなコードを実現できる。

```cpp
    // @@@ example/cpp03_syntax/class_08_ut.cpp #1:1 begin -1
```

なお、コピーコンストラクタ/コピー代入演算子を追加する前のコードが持っていた単純なコピーを[シャローコピー](---)と呼び、
このコード例のようなコピーを[ディープコピー](---)と呼ぶ。

上記コードには、C99には存在しない以下のようなシンタックスやキーワードを含む。

* [リファレンス](---)(型Tに対して、`T&`という形式)
* [this](---)
* [new/delete](---)
* [constメンバ関数](---)(宣言の末尾にconstがついているメンバ関数)


### this
thisとは、メンバ関数内で暗黙的に利用可能なポインタであり、
そのメンバ関数を呼び出したオブジェクト自身を指す。thisポインタを用いることで、
メンバ変数やメンバ関数に明示的にアクセスでき、
特にパラメータ名とメンバ変数名が衝突する場合や、オブジェクト自身を返す必要がある場合に有用である。

thisのポインタとしての型は、そのメンバ関数が[constメンバ関数](---)か否かによって異なる。

| メンバ関数関数    | thisの型(Tはクラス型)  |
|:----------------- |:----------------------:|
| 非constメンバ関数 | T* const               |
| constメンバ関数   | const T* const         |

thisポインタ自体は常にconst（再代入不可）である。
下記例にあるように呼び出し関数がメンバであることを明示するために用いることがある。

```cpp
    // @@@ example/cpp03_syntax/this_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/this_ut.cpp #0:1 begin -1
```

以下のPersonのコピー代入演算子のようにthisを使用し自己代入を避けることが一般的である。

```cpp
    // @@@ example/cpp03_syntax/class_08_ut.cpp #0:2 begin
```

### constメンバ関数
constメンバ関数は、オブジェクトの状態(非mutableメンバ変数)を変更しないことを宣言するメンバ関数である。
関数宣言の末尾にconst修飾子を付けて定義する。

- 意味論:  
    constメンバ関数内では、[this](---)ポインタが`const T*`型となり、
    非constメンバ変数への代入や非constメンバ関数の呼び出しができない。
- const正当性:  
    constオブジェクトからはconstメンバ関数のみ呼び出し可能である。
    これにより、const参照やconstポインタ経由でのアクセス時の安全性が保証される。
- 論理的const:  
    mutableキーワードを用いることで、
    論理的にはconstでも物理的には変更可能なメンバ(キャッシュ、カウンタなど)を実装できる。

```cpp
    // @@@ example/cpp03_syntax/const_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/const_ut.cpp #0:1 begin -1
```

### constメンバ変数
constメンバ変数は、オブジェクトの生存期間中、値が変更されないメンバ変数である。以下の特性を持つ。

- 初期化の必須性:  
    constメンバ変数は宣言時またはコンストラクタの初期化リストで必ず初期化しなければならない。
    コンストラクタ本体での代入は許されない。
- イミュータブル性:  
    一度初期化されると、オブジェクトの生存期間中、その値を変更することはできない。
- 設計上の利点:  
    変更不可能な属性を表現するのに適している。


コード例については、[constメンバ関数](---)を参照せよ。


### フレンド宣言
フレンド宣言とは、あるクラスのprivateおよびprotectedメンバーへのアクセス権を、
特定の関数またはクラスに対して付与する宣言である。通常、クラスの非公開メンバーは外部からアクセスできないが、
フレンド宣言を用いることで、信頼できる特定の対象に限定してアクセスを許可できる。

```cpp
    // @@@ example/cpp03_syntax/friend_ut.cpp #0:0 begin
```

__[特徴と注意点]__

* 非対称性  
  フレンド関係は一方向である。クラスAがクラスBをフレンドとして宣言しても、
  BがAのメンバーにアクセスできるだけで、AがBのメンバーにアクセスできるわけではない。
* 非推移性  
  フレンド関係は推移しない。AがBをフレンドとし、BがCをフレンドとしても、CはAのメンバーにアクセスできない。
* [継承]されない  
  フレンド関係は継承されない。基底クラスのフレンドは、派生クラスの非公開メンバーにアクセスできない。
* アクセス指定子との独立性  
  フレンド宣言は、クラス定義内のどのアクセス指定子セクション(private、protected、public)に記述しても同じ効果を持つ。

### 等値比較演算子
等値比較演算子(operator==)とは、2つのオブジェクトが等しいかどうかを判定するための演算子である。
C++では、クラスに対してこの演算子をオーバーロードすることで、そのクラス特有の等値性の定義を実装できる。
等値比較演算子は通常、メンバ関数ではなくフレンド関数または非メンバ関数として実装することが推奨される。
これは、左辺と右辺のオペランドを対称的に扱えるようにするためである。
メンバ関数として実装した場合、左辺が必ずそのクラスのオブジェクトでなければならないという制約が生じる。
演算子の戻り値はbool型であり、2つのオブジェクトが等しい場合にtrueを、そうでない場合にfalseを返す。
等値比較の実装においては、すべての意味のあるメンバ変数を比較対象に含める必要がある。
ただし、キャッシュやミュータブルな一時データなど、
オブジェクトの論理的な等価性に影響しないメンバは、通常、比較対象から除外する。
等値比較演算子を実装する際には、不等比較演算子(operator!=)も合わせて実装するのが一般的である。
C++20以降では、operator==のみを実装すればoperator!=は自動的に導出されるが、
それ以前のC++では両方を明示的に実装する必要がある。
また、等値比較演算子はや[コピーコンストラクタ/コピー代入演算子](---)は、
[等価性のセマンティクス](---)を満たす必要がある。

コード例は、次節で示す。


### Personのリファクタリング
これまで例示してきたPersonを以下の方針でリファクタリングを行う。

* 可読性向上のために、[Trailing Underscore(末尾アンダースコア)](---)に従う。
* メンバを適切にconst修飾することで、[constメンバ関数](---)/[constメンバ変数](---)へ変更する。
* Cでは、引数を持たない関数funcは`func(void)`のように宣言するが、C++では通常、単に`func()`と書く。
* 単体テストの利便性のためにPersonに[フレンド宣言](---)した[等値比較演算子](---)を追加する
  (セオリーではリファクタリングで機能変更するべきではないが、ドキュメントの構成上の都合でこうする)。

```cpp
    // @@@ example/cpp03_syntax/class_09_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/class_09_ut.cpp #0:1 begin -1
```

リファクタリングにより、以下の改善が実現された。

* メンバ変数名の末尾アンダースコアにより、引数名との区別が明確になった。
* メンバが適切にconst修飾されたことで可読性が向上した。
* malloc/freeからnew/deleteへ統一され、C++らしいメモリ管理となった。

## 標準ライブラリ
標準ライブラリとは、C++言語仕様の一部として規定されている、再利用可能なクラスや関数の集合である。
文字列処理、コンテナ、アルゴリズム、入出力、数値演算など、プログラム開発に必要な基本的な機能を提供する。
標準ライブラリを使用することで、車輪の再発明を避け、移植性の高いコードを記述できる。
すべての実装はstd名前空間に属しており、標準ヘッダファイルをインクルードすることで利用可能になる。
構成要素は膨大であるため、良く使用されるものの一部を以下に示す
([cpprefjp.github.io](https://cpprefjp.github.io/reference.html))。

| 標準ライブラリ| クラス等                                               |
|:--------------|:------------------------------------------------------ |
| 文字列処理    | std::string、std::wstringなど                          |
| コンテナ      | std::vector、std::list、std::mapなど                   |
| アルゴリズム  | std::sort、std::find、std::copyなど                    |
| 入出力        | std::cout、std::cin、ファイル入出力など                |
| 反復子        | コンテナの要素にアクセスするための統一インターフェース |

### std::stringの使用例 
std::stringはC++標準ライブラリが提供する文字列クラスである。C言語の文字配列(char[])と比較して、
メモリ管理が自動化されており、文字列操作が安全かつ容易になる。

Cでの文字列の結合と比較は下記のように記述される。

```cpp
    // @@@ example/cpp03_syntax/std_lib_ut.cpp #0:0 begin -1
```

C++では複雑な処理が、std::stringに押し込まれているため文字列の結合と比較は下記のように単純に記述できる。

```cpp
    // @@@ example/cpp03_syntax/std_lib_ut.cpp #0:1 begin -1
```

### 入出力(stream)
入出力(stream)とは、データの読み書きを抽象化した機能であり、C++標準ライブラリではiostreamライブラリとして提供される。
ストリームは、キーボード入力、画面出力、ファイル入出力など、
異なる入出力先を統一的なインターフェースで扱うことを可能にする。
C言語のprintf/scanfと比較して、型安全性が高く、ユーザー定義型に対する入出力の拡張が容易である。

```cpp
    // @@@ example/cpp03_syntax/std_lib_ut.cpp #1:0 begin -1
```

以下のストリームオブジェクトが定義されている。

| ストリームオブジェクト | 機能                 |
|:----------------------:|:-------------------- |
| std::cin               | 標準入力を扱う       |
| std::cout              | 標準出力を扱う       |
| std::cerr              | 標準エラー出力を扱う |

ストリームオブジェクトは以下のように使用する。

```cpp
    // @@@ example/cpp03_syntax/std_lib_ut.cpp #1:1 begin -1
```


ファイル入出力にはstd::ifstream(入力)、std::ofstream(出力)、std::fstream(入出力)を使用する。

```cpp
    // @@@ example/cpp03_syntax/std_lib_ut.cpp #1:2 begin -1
```

標準入出力やファイル入出力と同様に使用できるストリング入出力の使用例を以下に示す。

```cpp
    // @@@ example/cpp03_syntax/std_lib_ut.cpp #1:3 begin -1
```

### コンテナ
標準ライブラリのコンテナとは...



## 継承
継承は既存のクラスを拡張して新しいクラスを定義する機構である。既存のクラスを基底クラス(base class)、
新しく定義するクラスを派生クラス(derived class)と呼ぶ。
派生クラスは基底クラスのメンバ変数とメンバ関数を引き継ぐため、コードの再利用性が高まる。

以下の3種類の継承が規定されている。

- [public継承](---)
- [protectd継承](---)
- [private継承](---)

### public継承
public継承は最も一般的な継承方法であり、主に「[is-a](---)」関係を表現する際に使用される。
基底クラスのpublicメンバは派生クラスでもpublic、protectedメンバはprotectedのまま継承される。

```cpp
    // @@@ example/cpp03_syntax/derived_ut.cpp #0:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/derived_ut.cpp #0:1 begin -1
```

public継承では、
以下のコードのように派生クラスのオブジェクトを基底クラスのポインタや[リファレンス](---)として扱うことができる。
これによりポリモーフィズムが実現される。

```cpp
    // @@@ example/cpp03_syntax/derived_ut.cpp #0:2 begin -1
```

### protectd継承
protected継承は、基底クラスのpublicメンバとprotectedメンバがすべて派生クラスでprotectedになる。
外部からは基底クラスのメンバにアクセスできなくなる。

```cpp
    // @@@ example/cpp03_syntax/derived_ut.cpp #1:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/derived_ut.cpp #1:1 begin -1
```

protected継承は実装の詳細を隠蔽しつつ、
さらに派生したクラスには基底クラスのインターフェースを公開したい場合に使用される。使用頻度は低い。

### private継承
private継承は、基底クラスのpublicメンバとprotectedメンバがすべて派生クラスでprivateになる。
派生クラス内部でのみ基底クラスのメンバにアクセスでき、外部からも、さらに派生したクラスからもアクセスできない。

```cpp
    // @@@ example/cpp03_syntax/derived_ut.cpp #2:0 begin
```
```cpp
    // @@@ example/cpp03_syntax/derived_ut.cpp #2:1 begin -1
```

private継承は「[has-a](---)関係」や「[is-implemented-in-terms-of](---)関係」を表現する際に使用されることがある。
ただし、一般的にはメンバ変数として保持する方が意図が明確になるため、private継承の使用頻度は非常に低い。

### 派生
派生とは、継承を使って既存のクラスから新しいクラスを作り出すことである。この過程で、基底クラスの機能を受け継ぎつつ、
派生クラス独自の機能を追加したり、既存の機能を変更したりできる。

**派生の主な目的**は以下の通りである。

- 機能の拡張:  
  基底クラスの機能をそのまま利用しつつ、新しいメンバ変数やメンバ関数を追加することで、
  より特化した機能を持つクラスを定義できる。
- 機能の特殊化:  
  基底クラスの一般的な振る舞いを、派生クラスで特定の用途に合わせて変更できる。仮想関数のオーバライドにより、
  同じインターフェースで異なる実装を提供することが可能になる。
- コードの再利用:  
    共通する機能を基底クラスにまとめることで、重複したコードを避けられる。
    複数の派生クラスが同じ基底クラスを継承することで、保守性が向上する。

派生は多段階に行うことができる。派生クラスをさらに基底クラスとして、別の派生クラスを定義することが可能である。
これにより、クラスの階層構造を形成できる。階層が深くなると、
下位の派生クラスは上位のすべての基底クラスのメンバを継承する。ただし、階層を深くしすぎると設計が複雑になり、
保守性が低下する可能性があるため、適切な深さに抑えることが重要である。

派生クラスを設計する際は、「[is-a](---)」関係が成立するかを確認する必要がある。
派生クラスは基底クラスの一種であるという関係が自然に成り立つ場合に、public継承を使用するべきである。
また、派生クラスは基底クラスのインターフェースを尊重し、[リスコフの置換原則(LSP)](---)に従うことが望ましい。
これは、基底クラスのポインタや参照を通じて派生クラスのオブジェクトを操作しても、
プログラムの正しさが保たれるという原則である。

### オーバライド


--- 

## new/delete
Cの`malloc`/`free`と異なり、
C++ではメモリアロケーションとオブジェクトの生成と破棄を適切に行うために、以下の演算子が定義されている。

* [new演算子](---)/[delete演算子](---)
* [new[]演算子](---)/[delete[]演算子](---)

上記のnew演算子以外に[プレースメントnew](---)と[new (std::nothrow)](---)が定義されているが、
これらの対となるdeleteは存在しない。


### new演算子
### delete演算子
`new`演算子は、ヒープ上にメモリを確保し、オブジェクトを構築する。  
`delete`演算子は、`new`で確保したメモリを解放する前に、デストラクタを呼び出す。

```cpp
    // @@@ example/cpp03_syntax/new_delete_ut.cpp #0:0 begin -1
```

### new[]演算子
### delete[]演算子
配列を動的に確保する場合は、new[]とdelete[]を使用する。


```cpp
    // @@@ example/cpp03_syntax/new_delete_ut.cpp #1:0 begin -1
```

[注]

* クラスTに対し`new T[N]`を実行するためにはTがデフォルトコンストラクタを持つ必要がある。
* new[]でアロケートしたメモリはdelete[]で解放しなければならない。

## オーバーロード





